# Terraform Evaluation Rubric

## Overview

This rubric defines 14 rules for evaluating Terraform configurations generated by LLMs. 10 rules are fully automatable, 1 requires manual review (Rule 6: lifecycle), 2 are semi-automatable heuristics (Rules 7, 8), and 2 are conditional on the task (Rules 12, 13).

## Extraction Logic

The evaluator extracts Terraform HCL from raw LLM output using this priority:

1. **JSONL format** (opencode): Extract text parts from `type: "text"` events
2. **Claude CLI JSON**: Extract the `result` field from the CLI response envelope
3. **Fenced code blocks**: Look for content inside `` ```hcl ``, `` ```terraform ``, `` ```tf ``, or plain `` ``` `` blocks. Multiple fences are concatenated (LLMs often split into main.tf, variables.tf, etc.)
4. **Plain text**: Scan for lines starting with `terraform`, `provider`, `resource`, `variable`, `data`, `locals`, or `output` keywords

Trailing LLM explanation (e.g., "This configuration creates...") is trimmed using heuristics that detect meta-commentary after the last closing brace.

## Rule Reference Table

| # | Category | Rule | Auto | Pass Example | Fail Example |
|---|----------|------|------|-------------|-------------|
| 1 | NAMING | snake_case with descriptive prefix | Yes | `resource "aws_vpc" "main_vpc"` | `resource "aws_vpc" "vpc1"` |
| 2 | VARIABLES | All variables have `description` | Yes | `variable "name" { description = "..." }` | `variable "name" { type = string }` |
| 3 | VARIABLES | All variables have `type` constraint | Yes | `variable "name" { type = string }` | `variable "name" { default = "foo" }` |
| 4 | OUTPUTS | At least one `output` block | Yes | `output "vpc_id" { value = ... }` | No output blocks at all |
| 5 | TAGS | Tags on all taggable resources | Yes | `tags = { Environment = ... }` | `aws_instance` resource without tags block |
| 6 | LIFECYCLE | lifecycle on stateful resources | Manual | `lifecycle { prevent_destroy = true }` | No lifecycle on `aws_db_instance` |
| 7 | STRUCTURE | Variables grouped together | Semi | Variables at top, then resources | `resource {...} variable {...} resource {...}` |
| 8 | STRUCTURE | File structure mentioned | Semi | Comments like `# main.tf`, `# variables.tf` | Single block of code with no file hints |
| 9 | VALUES | No hardcoded IDs | Yes | `ami = data.aws_ami.al2023.id` | `ami = "ami-0c55b159cbfafe1f0"` |
| 10 | PROVIDER | Provider version pinned | Yes | `version = "~> 5.0"` in required_providers | No version constraint |
| 11 | BACKEND | Backend configured | Yes | `backend "s3" { ... }` | No backend block |
| 12 | SENSITIVE | Sensitive values marked | Cond. | `sensitive = true` on password variable | Password variable without sensitive flag |
| 13 | DATA | Data sources for lookups | Cond. | `data "aws_ami" "al2023" { ... }` | No data blocks when task requires lookups |
| 14 | LOCALS | Locals block present | Yes | `locals { common_tags = { ... } }` | No locals block |

## Detailed Rule Specifications

### Rule 1: Naming Convention

**Requirement**: All resource names must use `snake_case` with a descriptive prefix identifying the resource's purpose.

**Detection**: Regex check that names match `^[a-z][a-z0-9_]*$` and are not overly generic (matching `^[a-z]{1,3}\d*$`).

**Pass examples**:
- `resource "aws_vpc" "main_vpc"` -- descriptive
- `resource "aws_security_group" "app_security_group"` -- identifies role
- `resource "aws_subnet" "private_subnet_a"` -- clear function
- `resource "aws_instance" "web_server"` -- purpose clear

**Fail examples**:
- `resource "aws_vpc" "vpc1"` -- generic numbered name
- `resource "aws_security_group" "sg1"` -- abbreviated and generic
- `resource "aws_instance" "a"` -- single letter
- `resource "aws_subnet" "sub-1"` -- hyphens (not snake_case)
- `resource "aws_lb" "myALB"` -- camelCase

**Edge cases**:
- `resource "aws_vpc" "main"` passes (not matching the `^[a-z]{1,3}\d*$` pattern, and "main" is a common legitimate name for a single VPC)
- `resource "aws_iam_role" "this"` passes the regex check but is borderline (the `^[a-z]{1,3}\d*$` pattern catches 1-3 letter names)

### Rule 2: Variable Descriptions

**Requirement**: Every `variable` block must contain a `description` attribute.

**Detection**: For each variable block, search for `description =` within the block body.

**Pass**:
```hcl
variable "bucket_name" {
  description = "Name of the S3 bucket"
  type        = string
}
```

**Fail**:
```hcl
variable "bucket_name" {
  type    = string
  default = "my-bucket"
}
```

**Edge cases**:
- Empty description (`description = ""`) passes the regex check but is poor practice
- Description as a multi-line heredoc passes

### Rule 3: Variable Type Constraints

**Requirement**: Every `variable` block must contain a `type` attribute.

**Detection**: For each variable block, search for `type =` within the block body.

**Pass**:
```hcl
variable "instance_type" {
  description = "EC2 instance type"
  type        = string
  default     = "t3.micro"
}
```

**Fail**:
```hcl
variable "instance_type" {
  description = "EC2 instance type"
  default     = "t3.micro"
}
```

**Edge cases**:
- Complex types like `type = list(string)` or `type = object({ name = string })` pass
- `type = any` passes (it is a valid Terraform type)

### Rule 4: Outputs

**Requirement**: At least one `output` block must be defined.

**Detection**: Count `output "..." {` patterns.

**Pass**: Any configuration with one or more output blocks.
**Fail**: A configuration with zero output blocks.

**Edge cases**:
- Output with `sensitive = true` still counts
- Output commented out (`# output "..."`) does not count

### Rule 5: Tags

**Requirement**: All taggable AWS resources must include a `tags` block or `tags =` attribute.

**Detection**: For each resource whose type is in `TAGGABLE_RESOURCES`, check for `tags =` within the resource body.

**Taggable resources checked**: `aws_instance`, `aws_s3_bucket`, `aws_vpc`, `aws_subnet`, `aws_security_group`, `aws_lb`, `aws_ecs_cluster`, `aws_db_instance`, `aws_ecs_service`, `aws_ecs_task_definition`, `aws_cloudwatch_log_group`, `aws_eip`, `aws_nat_gateway`, `aws_internet_gateway`, `aws_route_table`, `aws_lb_target_group`, `aws_secretsmanager_secret`, `aws_iam_role`.

**Pass**:
```hcl
resource "aws_instance" "web_server" {
  ami           = data.aws_ami.al2023.id
  instance_type = var.instance_type
  tags = local.common_tags
}
```

**Fail**:
```hcl
resource "aws_instance" "web_server" {
  ami           = data.aws_ami.al2023.id
  instance_type = var.instance_type
  # No tags block
}
```

**Edge cases**:
- `tags = merge(local.common_tags, { Name = "web" })` passes
- `tags = var.tags` passes
- Resources NOT in the taggable list (e.g., `aws_route_table_association`, `aws_lb_listener`) are not checked
- `aws_s3_bucket_versioning` and similar sub-resources are in the taggable set but AWS may or may not support tags on them in practice; the evaluator checks them if present

### Rule 6: Lifecycle Blocks (MANUAL)

**Requirement**: Stateful resources (databases, S3 buckets, encryption keys) should include `lifecycle` blocks.

**Detection**: Always returns `True` with detail `"needs_review"`.

**Manual review guidance**:
- PASS: `lifecycle { prevent_destroy = true }` on `aws_db_instance`, `aws_s3_bucket`
- FAIL: `aws_db_instance` without any lifecycle block
- PASS: No stateful resources in the configuration (nothing to protect)
- Consider: `lifecycle { create_before_destroy = true }` is also valid for some use cases

### Rule 7: Variable Separation (SEMI)

**Requirement**: Variable blocks should be grouped together, not interspersed among resource blocks.

**Detection**: Extract ordered list of top-level `resource` and `variable` keywords. Check for the pattern: resource -> variable -> resource (interleaving).

**Pass**: Variables all appear before or after all resources.
**Fail**: `resource {...} variable {...} resource {...}`

**Edge cases**:
- If the output mentions file structure (e.g., separate variables.tf), assume variables are grouped even if the rendered single-file output interleaves
- No variables at all: returns `needs_review`

### Rule 8: File Structure (SEMI)

**Requirement**: The output should mention or suggest a multi-file structure (main.tf, variables.tf, outputs.tf).

**Detection**: Search for file name strings like "main.tf", "variables.tf", "outputs.tf", "data.tf", "locals.tf" in the output.

**Pass**: Output includes comments like `# main.tf` or text like "Save this as variables.tf"
**Pass with needs_review**: Single-file output with no file name hints

**Edge cases**:
- Multiple fenced code blocks labeled with filenames (e.g., `` ```hcl # main.tf ``) count
- Comments within the code like `# --- variables.tf ---` count

### Rule 9: No Hardcoded IDs

**Requirement**: No hardcoded AMI IDs, AWS account numbers, or region strings in resource blocks.

**Detection**:
- AMI IDs: regex `ami-[0-9a-f]{8,17}`
- Account numbers: 12-digit numbers (after stripping comments)
- Region strings: patterns like `"us-east-1"` outside of provider blocks

**Pass**: Uses `data.aws_ami.al2023.id` instead of `"ami-0c55b159cbfafe1f0"`
**Fail**: `ami = "ami-0c55b159cbfafe1f0"` directly in a resource

**Edge cases**:
- Region string in `provider "aws" { region = "us-east-1" }` is acceptable (provider blocks are excluded from the check)
- Region string in `terraform { backend "s3" { region = "us-east-1" } }` is also stripped
- 12-digit numbers in ARN strings may false-positive; comments are stripped to reduce noise
- Port numbers (e.g., `5432`, `443`) are only 3-4 digits so they do not trigger the 12-digit check

### Rule 10: Provider Version Pinned

**Requirement**: A `required_providers` block must exist with a `version` constraint.

**Detection**: Search for `required_providers {` and then `version = "..."` within the terraform block.

**Pass**:
```hcl
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}
```

**Fail**: No `required_providers` block, or `required_providers` without a version constraint.

**Edge cases**:
- `version = ">= 5.0, < 6.0"` passes (any quoted string after version =)
- Having `required_version` for Terraform itself is separate and does not satisfy this rule

### Rule 11: Backend Configured

**Requirement**: A `backend` block must be present in the `terraform` block.

**Detection**: Search for `backend "..." {` pattern.

**Pass**:
```hcl
terraform {
  backend "s3" {
    bucket = "my-state"
    key    = "terraform.tfstate"
  }
}
```

**Fail**: No backend block at all.

**Edge cases**:
- `backend "local" {}` technically passes (it is a valid backend)
- `cloud {}` block (Terraform Cloud) does not match the `backend "..."` pattern and will fail; this is a known limitation

### Rule 12: Sensitive Values (CONDITIONAL)

**Requirement**: Variables and outputs containing secrets must be marked `sensitive = true`.

**Detection**: Only checked when `task.requirements.sensitive_values == true`. Scans variable and output blocks for `sensitive = true`.

**Pass when required**:
```hcl
variable "db_password" {
  description = "Database password"
  type        = string
  sensitive   = true
}
```

**Fail when required**: Password/secret variable without `sensitive = true`.
**Auto-pass**: When `task.requirements.sensitive_values == false`.

### Rule 13: Data Sources (CONDITIONAL)

**Requirement**: Data source blocks must be present when the task requires dynamic lookups.

**Detection**: Only checked when `task.requirements.data_sources == true`. Counts `data "..." "..." {` patterns.

**Pass when required**: At least one `data` block.
**Fail when required**: No `data` blocks.
**Auto-pass**: When `task.requirements.data_sources == false`.

### Rule 14: Locals Block

**Requirement**: A `locals` block should be defined for shared or computed values.

**Detection**: Search for `locals {` pattern.

**Pass**: `locals { common_tags = { ... } }`
**Fail**: No `locals` block.

## Expected Outputs Per Task

### Task 1: S3 Bucket (task-1-s3-bucket.json) - Simple

**Expected passing configuration includes**:
- `terraform { required_providers { aws = { version = "~> 5.0" } } }` (Rule 10)
- `terraform { backend "s3" { ... } }` (Rule 11)
- Variables: `bucket_name` (string), `environment` (string), `project_name` (string) -- all with description and type (Rules 2, 3)
- `locals { common_tags = { ... } }` (Rule 14)
- Resources: `aws_s3_bucket`, `aws_s3_bucket_versioning`, `aws_s3_bucket_server_side_encryption_configuration`, `aws_s3_bucket_public_access_block`, `aws_s3_bucket_lifecycle_configuration`
- Tags on `aws_s3_bucket` (Rule 5)
- At least one output (e.g., `bucket_arn`, `bucket_id`) (Rule 4)
- Descriptive resource names like `app_bucket` not `bucket1` (Rule 1)

**Rule expectations**:
- Rule 1: descriptive snake_case names (PASS)
- Rule 2: all variables have description (PASS)
- Rule 3: all variables have type (PASS)
- Rule 4: at least one output (PASS)
- Rule 5: tags on aws_s3_bucket (PASS)
- Rule 6: lifecycle (PASS/needs_review)
- Rule 7: variables grouped (PASS)
- Rule 8: file structure (PASS or needs_review)
- Rule 9: no hardcoded IDs (PASS -- simple task, no AMIs)
- Rule 10: provider pinned (PASS)
- Rule 11: backend configured (PASS)
- Rule 12: sensitive (PASS/n/a -- task does not require)
- Rule 13: data sources (PASS/n/a -- task does not require)
- Rule 14: locals (PASS)

**Perfect score**: 14/14

### Task 2: VPC + EC2 (task-2-vpc-ec2.json) - Medium

**Expected passing configuration includes**:
- Provider and backend (Rules 10, 11)
- Variables: `aws_region`, `instance_type`, `ssh_cidr`, `project_name`, `environment` (Rules 2, 3)
- Data source: `data "aws_ami" "amazon_linux" { ... }` (Rule 13)
- Resources: `aws_vpc`, `aws_subnet` x4, `aws_internet_gateway`, `aws_nat_gateway`, `aws_route_table`, `aws_security_group`, `aws_instance`, `aws_eip`
- Tags on all taggable resources (Rule 5)
- Outputs: `vpc_id`, `public_subnet_ids`, `ec2_public_ip` (Rule 4)
- `locals { common_tags = { ... } }` (Rule 14)
- No hardcoded AMI IDs -- uses data source (Rule 9)

**Rule expectations**:
- Rules 1-5, 10, 11, 14: PASS
- Rule 6: PASS/needs_review
- Rules 7, 8: PASS or needs_review (semi)
- Rule 9: PASS (AMI from data source)
- Rule 12: PASS/n/a (no sensitive requirement)
- Rule 13: PASS (data source present)

**Perfect score**: 14/14

### Task 3: ECS Fargate (task-3-ecs-fargate.json) - Complex

**Expected passing configuration includes**:
- Provider and backend (Rules 10, 11)
- Variables with descriptions and types including: `ecr_image`, `certificate_arn`, `vpc_id`, `public_subnet_ids`, `private_subnet_ids`, `db_password` (sensitive), `environment`, `project_name` (Rules 2, 3)
- `db_password` marked `sensitive = true` (Rule 12)
- Data source for IAM policy documents or caller identity (Rule 13)
- Resources: `aws_ecs_cluster`, `aws_ecs_task_definition`, `aws_ecs_service`, `aws_lb`, `aws_lb_target_group`, `aws_lb_listener`, `aws_db_instance`, `aws_secretsmanager_secret`, `aws_iam_role` x2, `aws_security_group` x3, `aws_cloudwatch_log_group`
- Tags on all taggable resources (Rule 5)
- Outputs: `alb_dns_name`, `ecs_service_name` (Rule 4)
- `locals` block (Rule 14)

**Rule expectations**:
- Rules 1-5, 10, 11, 14: PASS
- Rule 6: PASS/needs_review
- Rules 7, 8: PASS or needs_review (semi)
- Rule 9: PASS (no hardcoded IDs)
- Rule 12: PASS (sensitive = true on db_password)
- Rule 13: PASS (data sources present)

**Perfect score**: 14/14

## Scoring

- **auto_score**: Count of rules that pass (0-14). Rule 6 always contributes 1 (returns True).
- **Effective auto rules**: 10 fully automatable + 2 semi + 1 manual + up to 2 conditional = 14 total.
- **needs_manual_review**: True when any rule returns `"needs_review"` in its detail. Always True because Rule 6 always flags needs_review, and Rule 8 often does too.
- **Perfect auto score**: 14 (all automated rules pass + Rule 6 placeholder + conditional rules either pass or n/a).
- **Minimum meaningful score**: A structurally valid Terraform config with basic resources should score at least 8/14.

## CSV Output Columns

| Column | Description |
|--------|-------------|
| run_id | Unique identifier for the run |
| model | LLM model used |
| condition | "markdown" or "pseudocode" |
| task | Task ID |
| task_complexity | simple, medium, complex |
| rep | Repetition number |
| duration_ms | Response time in milliseconds |
| extraction_ok | Whether Terraform HCL was extracted |
| extraction_error | Error message if extraction failed |
| structure_valid | Whether at least one resource block was found |
| structure_errors | List of structural errors |
| rule_N_X_pass | Boolean pass/fail for rule N |
| rule_N_X_detail | Detail string for rule N |
| auto_score | Total rules passed (0-14) |
| needs_manual_review | Whether manual review is needed |

## Edge Cases: Multi-file vs Single-file Output

LLMs may produce Terraform output in different formats:

1. **Single code fence**: All resources in one block. Variables may be interspersed.
2. **Multiple code fences**: Separate blocks labeled with filenames (main.tf, variables.tf, etc.). The evaluator concatenates all fences.
3. **Mixed text and code**: Explanation text between code fences. The evaluator extracts and concatenates only HCL-like content.
4. **Module structure**: LLM may create a module with `module "..." { source = "./modules/..." }`. Module internals are evaluated as concatenated text.

## Edge Cases: Dynamic Blocks and Expressions

- `dynamic "tag" { ... }` blocks: The evaluator looks for `tags =` within the resource body. A `dynamic "tag"` block would not match this pattern and would be a false negative for Rule 5. This is a known limitation.
- `for_each` and `count`: Resources using `for_each` are matched once by the regex. The evaluator does not account for multiple instances.
- Terraform expressions like `merge(local.tags, { ... })`: These pass the `tags =` check since it matches the `tags = merge(` pattern.
